## 基础

### 数据结构

基本包括



#### HashMap

数据结构：散列桶数组 + 链表

一般简单的HashMap，大致流程，key值经过计算打散到散列数组对应位置，以链表形式挨个比对完成对应操作

主要了解：**扰动函数、初始化容量、负载因子、扩容方法以及链表和红黑树转换的使用**

##### 扰动函数

**散列数组的index，为什么不直接Key的hashCode值取余length，而是多了一次扰动计算**

> **String的hashCode方法，为什么选择31作为乘积值？**
>
> 31为奇质数，偶数会导致乘积运算时数据溢出；31 = 2<<5-1,乘积运算可以使用位移提升性能；
>
> hash碰撞概率小（运算过程在int取值范围内），基本稳定。

HashMap，key通过Hash计算索引位置，然后找到对应元素或链表或树，为什么不直接取余(&(size-1))？

key的hashCode，进行一次**扰动计算**，哈希值右移16位（默认初始化大小16长度），与原哈希做异或，这样混合了原哈希值中的高位和地位，增大了**随机性**，进一步**减少了哈希碰撞**，分布的更均匀

##### 初始化容量和负载因子

负载因子默认0.75，就是说当阀值容量占了3/4 时赶紧扩容，减少 Hash 碰撞

##### 扩容元素拆分

扩容方式就是需要把元素拆分到新的数组中。

拆分元素的过程中，原 jdk1.7 中会需要重新计算哈希值，但是到 jdk1.8 中已经进行优化，不在需要重新计算



**基本的数据操作功能：存储、删除、获取、遍历**

- 存储删除操作可能会遇到哈希碰撞（equals，替换或者插入（树化）），可能会遇到扩容，扩容后，原来因为哈希碰撞存放的链表或者红黑树，都需要进行拆分存放



### ArrayList

数据结构：数组

创建一个集合，初始容量不指定时为0，在第一次添加元素时，集合会扩容为10；继续添加至超过上限，会继续扩容为原来的3/2，也就是15

Arrays.asList构建的集合，不能再添加，不能再删除



### JVM性能调优

#### JVM参数配置最佳实践

在一个机器中JVM进程占用总内存(堆，元空间，堆外内存，CodeCache)一般不建议超过总内存的80%

| JVM参数                   | 说明                    | 4c8g | 8c16g |
| ------------------------- | ----------------------- | ---- | ----- |
| -Xms                      | 初始堆内存大小          | 4g   | 10g   |
| -Xmx                      | 最大堆内存大小          | 4g   | 10g   |
| -Xmn                      | 新生代空间大小          | 2g   | 5g    |
| -XX:MetaspaceSize         | 初始元空间大小          | 384m | 512m  |
| -XX:MaxMetaspaceSize      | 最大元空间大小          | 384m | 512m  |
| -XX:MaxDirectMemorySize   | 最大堆外内存大小        | 1g   | 1g    |
| -XX:ReservedCodeCacheSize | CodeCache(本地方法)大小 | 256m | 256m  |

不分机器的通用配置

-XX:SurvivorRatio=10，survivor区大小为新生代的1/12

-XX:ParallelGCThreads=${CPU_COUNT}，并发GC线程数（Young GC 在jdk1.8默认使用多线程线性收集器）

-XX:+UseConcMarkSweepGC ，old区使用CMS GC

-XX:CMSMaxAbortablePrecleanTime=5000， CMS GC的回收超时时间，避免GC太久

-XX:CMSInitiatingOccupancyFraction=80 ，Old区达到80%触发CMS GC，如果不设置，JVM会自适应，效果不好

-XX:UserCMSInitiatingOccupancyOnly，必须配置这个，上面这个Fraction配置才会生效

-XX:+CMSScavengeBeforeRemark，执行GMS GC的remark前先Young GC一次，缩短remark时间（会有跨代引用，老年代进行GC Roots追踪时，同样会扫描年轻代） 

-XX:+ExplicitGCInvokesConcurrent， 调用System.gc()时触发CMS GC而不是Full GC

-XX:HeapDumpOnOutOfMemoryError，OOM时自动jmap dump内存

-XX:HeapDumpPath=/home/admin/logs/java.hprof，OOM时dump内存的位置

-Xloggc:/home/admin/logs/gc.log，GC log位置

-XX:+PrintGCDetails，打印GC详细信息

-XX:+PrintGCDeteStamps，将GC时间戳改为人类可识别的时间刻

-XX:+UseGCLogFileRotation，开启GC日志文件轮询

-XX:GCLogFileSize=50M，每个GC日志文件最大大小

-XX:NumberOfGCLogFiles=5，保留的GC日志文件个数





多线程顺序执行

- join方法等待线程销毁，阻塞主线程

- CountDownLatch倒数计时器

  ```java
  CountDownLatch countDownLatch1 = new CountDownLatch(1);
  countDownLatch1.await();
  doSomething();
  countDownLatch2.countDown();
  ```

- 单线程线程池，newSingleThreadExecutor()



强引用，软引用，弱引用，虚引用

**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**

程序里面最快的缓存就是直接在内存里面构建缓存。但是如果我们使用强引用构建缓存的话，一旦缓存过大无法回收就会导致内存溢出。这个时候我么可以使用软引用构建缓存。

```java
// 软引用
Caffeine.newBuilder().softValues().build();
```



JVM垃圾收集器

Serial（串行）收集器（**新生代采用复制算法，老年代采用标记-整理算法**）

**ParNew 收集器（ Serial 收集器的多线程版本）**

Parallel Scavenge 收集器（与ParNew几乎一样，关注点吞吐量，高效率利用CPU）**JDK1.8 默认收集器**

**CMS（Concurrent Mark Sweep）收集器，最短回收停顿时间为目标的收集器。注重用户体验**， **“标记-清除”算法**(**并发收集、低停顿**)，参考https://blog.csdn.net/zqz_zqz/article/details/70568819

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征**

[ZGC](https://wiki.openjdk.java.net/display/zgc/Main)（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器(在 ZGC 中出现 Stop The World 的情况会更少，目标10ms)



##### TCP三次握手四次挥手

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

断开，多一次是因为服务器再知道断开请求之后还会传完一小部分数据，然后在断



##### 在浏览器中输入url地址 ->> 显示主页的过程

总体来说分为以下几个过程:

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束



## 线程安全

jvm内存模型，jvm线程模型

java内存模型

得出线程安全讲的是什么？线程是什么，什么又叫做安全？

https://blog.csdn.net/u014730165/article/details/81981154

JVM调优



## MYSQL索引

MYSQL索引的数据结构，BTree，哈希

MYSQL引擎，MyISAM，InnoDB

https://www.cnblogs.com/jiawen010/p/11805241.html

InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分；

我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需找主键索引的二级索引，现在找到主键索引再通过主键索引找数据；

**MyISAM与InnoDB的对比：**

1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
2. InnoDB使用的是**聚簇索引**，MyISM使用的是**非聚簇索引**
3. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
4. **是否支持外键：** MyISAM不支持，而InnoDB支持。
5. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。



### Spring Cloud基础组件

> 注册与发现（Eureka,Zookeeper,Consul）
>
> 负载均衡（Ribbon）
>
> Api网关（Gateway, Zuul）
>
> REST调用（Feign）
>
> 容错处理（Hystrix）
>
> 统一管理配置（Config, Apollo,Nacos）
>
> 服务跟踪（Sleuth）



微服务组件——**网关**

一般情况下，**网关**一般都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能

**网关**实现核心，过滤器，路由

常用网关，Kong 基于 Openresty ，Zuul 基于 Java，SpringGateway

基于云平台的产生的概念Service Mesh（服务网格），相较传统部署来说，云平台优点弹性伸缩，相当于云平台的智能网关；

常用Service Mesh，linkerd基于主机部署， istio仅应用与Kubernetes

限流算法：固定窗口，滑动窗口，漏桶，令牌桶		



微服务组件——**注册中心**

主要功能，服务注册和服务发现，监控，负载均衡

典型的分布式系统，需要支持高可用

**CAP**原则指的是在一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，不能同时成立

一致性和可用性不能同时满足。在注册中心的发展上面，一直有两个分支：一个就是 CP 系统，追求数据的强一致性。还有一个是 AP 系统，追求高可用与最终一致。我们接下来介绍的服务注册和发现组件中，Eureka满足了其中的AP，Consul和Zookeeper满足了其中的CP

**服务注册 Register**：

官方解释：当 `Eureka` 客户端向 `Eureka Server` 注册时，它提供自身的**元数据**，比如IP地址、端口，运行状况指示符URL，主页等

**服务续约 Renew**：

官方解释：**`Eureka` 客户会每隔30秒(默认情况下)发送一次心跳来续约**。 通过续约来告知 `Eureka Server` 该 `Eureka` 客户仍然存在，没有出现问题。 正常情况下，如果 `Eureka Server` 在90秒没有收到 `Eureka` 客户的续约，它会将实例从其注册表中删除

**获取注册列表信息 Fetch Registries**：

官方解释：`Eureka` 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 `Eureka` 客户端的缓存信息不同, `Eureka` 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，`Eureka` 客户端则会重新获取整个注册表信息。 `Eureka` 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。`Eureka` 客户端和 `Eureka` 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 `Eureka` 客户端使用压缩 `JSON` 格式来获取注册列表的信息。

**服务下线 Cancel**：

官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：`DiscoveryManager.getInstance().shutdownComponent();`

**服务剔除 Eviction**：

官方解释：在默认的情况下，**当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除**，即服务剔除。

zk扩展 https://blog.csdn.net/dwdyoung/article/details/80726883



微服务组件——**负载均衡**（Ribbon）

> **`RestTemplate`是`Spring`提供的一个访问Http服务的客户端类**
>
> 微服务之间的调用是使用的 `RestTemplate`
>
> 上面我们所讲的 `Eureka` 框架中的 **注册**、**续约** 等，底层都是使用的 `RestTemplate`

**运行在消费者端**，也就是调用方，其工作原理就是 `Consumer` 端获取到了所有的服务列表之后，在其**内部**使用**负载均衡算法**，进行对多个系统的调用

请注意 `Request` 的位置，在 `Nginx` 中请求是先进入负载均衡器，而在 `Ribbon` 中是先在客户端进行负载均衡才进行请求的。所以`Ribbon` 是一种**集中式**的负载均衡器

负载均衡器Ribbon调度算法

- **`RoundRobinRule`**：轮询策略。`Ribbon` 默认采用的策略。若经过一轮轮询没有找到可用的 `provider`，其最多轮询 10 轮。若最终还没有找到，则返回 `null`。
- **`RandomRule`**: 随机策略，从所有可用的 `provider` 中随机选择一个。
- **`RetryRule`**: 重试策略。先按照 `RoundRobinRule` 策略获取 `provider`，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。



微服务组件——**REST调用**（Open Feign）

理论上有了 `Eureka` ，`RestTemplate` ，`Ribbon`， 我们就可以愉快地进行服务间的调用；但不方便；故利用映射，注解简化服务间调用

`OpenFeign` 也是运行在消费者端的，使用 `Ribbon` 进行负载均衡，所以 `OpenFeign` 直接内置了 `Ribbon`



微服务组件——**容错处理**（Hystrix之熔断和降级）

> 在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。

A --> B --> C C程序有问题，导致大量请求阻塞；过一会之后，B会因为C的阻塞而变得阻塞，同理，A也会。这种现象叫做**服务雪崩**

**熔断** 就是指的 `Hystrix` 中的 **断路器模式** ，你可以使用简单的 `@HystrixCommand` 注解来标注某个方法

```java
@HystrixCommand(
    commandProperties = {@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "1200")}
)
public List<Xxx> getXxxx() {
    // ...省略代码逻辑
}
```

降级，是一种比断路模式更友好的一种模式，可指定后背方法进行安抚用户

```java
// 指定了后备方法调用
@HystrixCommand(fallbackMethod = "getHystrixNews")
```



微服务组件——**统一管理配置，配置中心**（Spring Cloud Config）

简单来说，`Spring Cloud Config` 就是能将各个 应用/系统/模块 的配置文件存放到 **统一的地方然后进行管理**(Git 或者 SVN)。

你想一下，我们的应用是不是只有启动的时候才会进行配置文件的加载，那么我们的 `Spring Cloud Config` 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。

可以*使用 Spring Cloud Bus （需要借助消息Kafka）来自动刷新多个端*



### ElasticsSearch vs MongoDB

https://www.sohu.com/a/283594658_505800