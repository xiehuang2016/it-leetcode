## MQ

### MQ的消息模型

- 队列模型（也叫点对点）
- 发布-订阅模型（借助Queue或者Partition多个'点对点'并发）

在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）

实际上，在这种发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，发布 - 订阅模型在功能层面上是可以兼容队列模型的

> 现代的消息队列产品使用的消息模型大多是这种发布 - 订阅模型
>
> RabbitMQ是个例外，依然坚持使用队列模型的产品，生产者会将消息发到Exchange，Exchange根据配置的策略来决定消息投递到哪些队列，同一份消息如果需要被多个消费者消费，则Exchange发送消息到多个队列，也就是说每个队列都保存一份完整的消息数据
>
> RocketMQ是典型的发布 - 订阅模型
>
> 每个主题包含多个队列，**通过多个队列来实现多实例并行生产和消费**。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。
>
> ![img](https://static001.geekbang.org/resource/image/46/17/465142ab5b5096f283118c307e8cc117.jpg)
>
> Kafka消费模型
>
> 所有 RocketMQ 中对应的概念，和生产消费过程中的确认机制，都完全适用于 Kafka。唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，Kafka 中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的



### 事务消息实现分布式事务

事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能

![img](https://static001.geekbang.org/resource/image/27/e6/27ebf12e0dc79e00e1e42c8ff0f4e2e6.jpg)

首先，订单系统在消息队列上开启一个事务。然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。

如果在第四步提交事务消息时失败了怎么办？对于这个问题，Kafka 和 RocketMQ 给出了 2 种不同的解决方案

kafka直接抛出异常，让用户自行处理，RocketMQ事务反查机制处理（在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务）



### 消息积压怎么办

- 设计或者优化性能避免

在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行。

**提高并行消费速度**，在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。原因我们之前讲过，因为对于消费者来说，在每个分区上实际上只能支持单线程消费。

- 要么是发送变快了，要么是消费变慢了
  - 消费提升，唯一的方法是通过扩容消费端的实例数来提升总体的消费能力。
  - 生产减速，如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。



### redis的订阅/发布

https://www.cnblogs.com/qlqwjy/p/9763754.html





#### 消息中间件，有没有遇到丢失的情况 https://www.jianshu.com/p/4491cba335d1

- 生产者丢了数据

  - RabbitMQ 提供的事务功能，生产者发送，服务端未成功接收，生产者回滚，强一致性，一般不采用
  - RabbitMQ开启confirm模式，前者同步的，这个是异步的，发送消息后，等待服务器接收后的ack异步回调，一般用confirm模式
  - **[Kafka]**producer端设置acks=all，要求每条数据，必须是**写入所有 replica 之后，才能认为是写成功了**

- 消息中间件丢了数据

  - 开启持久化，RabbitMQ开启持久化
  - **[Kafka]**topic设置`replication.factor` 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本； **&** Kafka 服务端设置 `min.insync.replicas` 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系（场景：leader挂掉，follow切leader，可能会丢数据；）

- 消费端弄丢了数据

  - 关闭RabbitMQ的自动ACK，手动消费处理完后，手动调用ACK一次；防止未消费结果进程挂了，却自动ACK。注意保持幂等
  - **[Kafka]**关闭自动提交offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。注意保持幂等

  

#### Kafka发送消息消费消息的过程

##### 发送消息

异步将记录发送到主题，并在确认发送后调用提供的回调。发送是异步的，一旦记录存储在等待发送的记录缓冲区中，此方法将立即返回。这允许并行发送多个记录，而无需在每个记录之后等待响应。

todo 



### 消息队列算法自实现基本逻辑

 https://my.oschina.net/u/3959468/blog/2989038